# 概念性问题

## 1.1.定义：创建变量或分配单元
## 1.2.声明：说明变量的性质，但并不分配存储单元
---
## 2.1 所有整型都包括signed（带符号）和unsigned（无符号）两种形式
## 2.2 命名规范：
### - 变量名使用小写字母，符号常量名全部使用大写字母
## 2.3： 如何理解 [对于内部名而言，至少前31个字符是有效的。函数名与外部变量名包含的字符数目可能小于31，这是因为汇编程序和加载程序可能会使用这些外部名，而语言本身是无法控制加载和汇编程序的]
| 特性 | 内部名 (Internal Name) | 	外部名 (External Name) |
| :-----| ----: | :----: |
| 作用域 | 单个 .c 文件内 | 整个项目（所有 .c 文件） |
| 管理者 | 	编译器 (Compiler) | 链接器 (Linker) |
| 比喻 | 部门内部昵称 | 公司系统官方代号 |
| 历史限制	 | C标准保证至少31个字符有效 | 取决于链接器，可能短至6或8个字符
 |
## 2.4 数据类型
### 基本数据类型
- char 字符型，占用一个字节
- int 整型
- float 单精度浮点型
- double 双精度浮点型


| 特性 | 单精度 (float) | 双精度 (double) |
| :--- | :--- | :--- |
| **比喻** | 普通的学生尺 | 高精度的激光测量仪 |
| **内存占用** | **较小** (通常是 **4** 个字节) | **较大** (通常是 **8** 个字节) |
| **精度** | **较低** (约 6-7 位有效十进制数字) | **更高** (约 15-16 位有效十进制数字) |
| **数值范围** | **较小** (大约 10⁻³⁸ 到 10³⁸) | **巨大** (大约 10⁻³⁰⁸ 到 10³⁰⁸) |
| **处理速度** | 在某些旧的或嵌入式硬件上**可能更快** | 在现代 CPU 上通常一样快，甚至更快 |
| **默认类型** | 不是默认的 | C 语言中，浮点数常量 (如 `3.14`) **默认为 `double`** |

### 基本数据类型前的限定符：short/long
### 类型限定符signed 与unsigned 可用于限定char 类型或任何整型
## 2.5 按位运算符
### 只能用于整型操作数，即只能用于带符号或无符号，即：char, short, int, long
- & 按位与
- | 按位或
- ^ 按位异或
- << 左移
- `>>` 右移
- ~ 按位求反 (一元运算符)
### 用法1. n = n & 0177 [按位与运算符&经常用于屏蔽某些二进制位]:`屏蔽掉变量 n 中除了最低 7 位之外的所有位，确保 n 的值落在 0 到 127 的范围内`[通常用于将一个字符强制转换为标准的 7-bit ASCII 字符]
### 用法2. x = x | SET_ON [按位或运算符|常用于将某些二进制位置为1]： `该语句将x中对应于SET_ON中为1 的那些二进制位置为1`
### 用法3. 按位异或运算符^当两个操作数的对应位不相同时将该位设置为1
### 用法4. 移位运算符<<与>>分别用于将运算的左操作数左移与右移 ： `表达式x << 2 将把x 的值左移2 位，右边空出的2 位用0 填补 [该表达式等价于对左操作数乘以4]` 
### 用法5. 一元运算符~用于求整数的二进制反码 ： `x = x & ~077` [把x的最后6位设置为0]
###用法6. 理解下面的代码: 
```
/* getbits: get n bits from position p */
unsigned getbits(unsigned x, int p, int n)
{
return (x >> (p+1-n)) & ~(~0 << n);
}
```
## 2.6复制运算符与表达式
### 用法1. 大多数二元运算符（即有左、右两个操作数的运算符，比如+）都有一个相应的赋值运算符op=，其中，op可以是下面这些运算符之一： `+ - * / % << >> & ^ |` [如果expr1和expr2是表达式，那么expr1 op= expr2 等价于：expr1 = (expr1) op (expr2)]
### 用法2. 理解下面代码：函数bitcount统计其整型参数的值为1的二进制位的个数
```
/* bitcount: count 1 bits in x */
int bitcount(unsigned x)
{
int b;
for (b = 0; x != 0; x >>= 1)
if (x & 01)
b++;
return b;
}
这里将x 声明为无符号类型是为了保证将x 右移时，无论该程序在什么机器上运行，左边空
出的位都用0（而不是符号位）填补。
```
## 2.7 条件表达式
### 用法1. `if else` 语句可等同于 `expr1 ? expr2 : expr3`
解释：[首先计算expr1，如果其值不等于0（为真），则计算expr2 的值，并以该值作为条件表达式的值，否则计算expr3 的值，并以该值作为条件表达式的值。expr2 与expr3 中只能有一个表达式被计算]


## 其他
- 前缀为0的整型常量： 八进制
- 前缀为0x/0X: 十六进制
- 一个字符常量是一个整数(将字符括在单引号中)： ‘x’的值为48
- \ooo: 1～3个八进制数字
- \xhh: hh表示一个或多个十六进制数
- 字符常量‘\0’: 值为0的字符，即空字符.用'\0'的形式代替0，以强调某些表达式的字符属性，但其数字值为0
- 字符常量对比仅包含一个字符的字符串: ：'x'与"x"是不同的。前者是一个整数，其值是字母x 在机器字符集中对应的数值（内部表示值）；后者是一个包含一个字符（即字母x）以及一个结束符'\0'的字符数组。
- 枚举：建立常量值与名字之间的关联
- 取模运算符%不能应用于float 或double 类
- char类型就是较小的整型

| 对比视角 | 解释 |
| :--- | :--- |
| **物理本质** | `char` 就是一个占用1字节内存的整型。它的能力是存储一个小范围的整数。 |
| **逻辑用途** | 它被设计用来存储字符的 ASCII 码值。C 语言的库函数和语法糖 (比如用单引号 `'A'` 赋值) 让它看起来像是在直接操作字符。 |

- `s[i] - '0'` ： 计算出s[i]中存储的字符所对应的数字值
- C语言的定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。但是，存储在字符变量中的位模式在某些机器中可能是负的，而在另一些机器上可能是正的。为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed或unsigned限定符。
- 理解：，-1L < 1U， 结果为false
- ++n先将变量n的值递增1,之后在使用n的值; n++则是先使用变量n的值，之后将n的值递增1
- 