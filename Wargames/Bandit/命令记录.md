# 所有涉及的命令
## - ssh
### ssh -i `告诉SSH客户端：“不要使用默认的钥匙，请用我（-i）指定的这把特殊的私钥（identity file）去尝试开门（登录服务器）”`
### - 用法：`ssh -i <私钥文件路径> <用户名>@<主机地址>`
## - pwd
## - cat
---
## - -rw-r-----   1 bandit2 bandit1   33 Jul 28 19:03 -
### ***1.第一位(-):*** `文件类型. -:普通文件; d:目录; l:链接`
### ***2.第2-4位(rw-):*** `文件所有者权限`
### ***3.第5-7位(r--):*** `文件所属组权限: 与文件所有者同在一个用户组的用户`
### ***4.第8-10位(r--):*** `其他用户的权限: 系统里任何其他用户`
### ***5:(1)硬链接数:***  `对于文件，这个数字通常是1。它表示有多少个文件名指向这个文件的实际数据块`
### ***6.bandit2:*** `文件所有者： 这个文件属于名为 bandit2 的这个用户`
### ***7.bandit1:*** `文件所属组： 这个文件属于名为 bandit1 的这个用户组`
### ***8.(33)：*** `文件大小： 这个文件的大小是 33 字节 (Bytes)`
### ***9.(Jul 28 10:03)*** `最后修改时间： 这个文件最后一次被修改的日期和时间是 7月28日 10:03`
### ***10.(-)*** `文件名: - 是一个特殊符号，它通常代表**“标准输入”(stdin)**，也就是让命令从键盘、而不是从文件读取数据`
### ***11.如何查看(-)文件*** `: cat ./- : 告诉Shell这个-是一个文件，而不是一个特殊符号的最简单方法，就是为它提供一个路径，哪怕只是当前路径。`
---
## --spaces in this filename-- `文件名`
---
## find ` 语法结构：  find   [在哪里找]   [找什么样的]   [找到后做什么]`
### ***1. 按文件名查找 (-name) [-name 参数支持使用通配符（如 * 和 ?）][忽略大小写查找： 使用 -iname (ignore case)]*** 
#### - 在当前目录下，查找所有.log结尾的文件： `find . -name "*.log"`
#### - 只查找目录 `find . -type d -name "config"`
#### - 只查找普通文件 `find . -type f -name "*.conf"`
### ***2. 按文件大小查找***
#### - 查找大于/小于/等于100MB的文件： `find /var/log -type f -size +100M/-100M/100M` 
#### - 查找等于50字节的文件： `find . -type f -size 50c`
#### - 查找当前目录下，属于用户john的、并且大于10MB的.zip文件 `find . -user "john" -type f -name "*.zip" -size +10M`
---
## 2>/dev/null
## grep
## sort `sort 命令的作用就是对文本文件的行进行排序。默认情况下，它按照字典顺序（从 a 到 z，从 0 到 9）进行排序。`
### 1.排序/反向排序[r 代表 reverse] `sort fruits.txt / sort -r fruits.txt`
### 2.按数字大小排序(-n)[numeric]
---
## uniq: 去重计数器
### 1.uniq 命令用于报告或移除文本文件中连续的、重复的行[最重要的前提：uniq 命令只能处理“已排序”好的数据。 它只会比较相邻的两行是否相同。因此，在使用uniq之前，通常必须先用sort对文件进行排序。]
### 2.去重(默认操作)[必须先sort] ` sort fruits.txt | uniq`
### 3.统计每行出现的行数(-c)[count] `sort fruits.txt | uniq -c`
### 4.只显示重复过的行 (-d)[duplicated]: `sort fruits.txt | uniq -d`
### 5.只显示没有重复过的行 (-u)[unique]: `sort fruits.txt | uniq -u` 
---
## base64
## xxd 文件格式翻译器 `它可以在“计算机看的”二进制文件和“人看的”十六进制文本之间进行双向转换`
### 解释：xxd： 就像一位能听写乐谱也能演奏乐谱的音乐家 
#### - 正向操作 (xxd file): 音乐家听到音乐，把它写成乐谱（十六进制文本），方便人类阅读和分析
#### - 反向操作 (xxd -r): 音乐家看到乐谱，把它演奏出来，还原成原始的音乐（二进制文件）
---
## gunzip[解压]/gzip[压缩] `gunzip 是一个专门用来解压缩文件的命令行工具，它主要处理以 .gz 为后缀的、由gzip命令压缩的文件`
### 解压文件[默认会删除原始文件] `gunzip <文件名.gz>`
### -k[keep] 保留原始文件
---
## bunzip2 `是一个专门用来解压缩使用 bzip2 算法压缩的文件的命令行工具`
### 解压文件[默认删除原始文件] `bunzip2 archive.tar.bz2`
### -k[keep] 保留原始文件
---
## 解压tar文件 `tar -xvf`
### -x: extract (提取)，这是“解包”的核心指令。
### -v: verbose (详细)，在解压时显示每一个被提取出来的文件名，能看到过程
### -f: file (文件)，后面必须紧跟着解压的文件名。
---
## nc ` (它的全称是 Netcat) 是一个底层的、多功能的网络工具，被誉为“网络工具中的瑞士军刀”。它能在计算机之间通过TCP或UDP协议读取和写入数据`
### 一个简单的比喻：可以把nc想象成一个“万能的网络管道工”。它不关心管道里流动的是什么（是网页、文件还是聊天信息），它只负责建立管道、传输数据。它可以扮演“水龙头”的角色（客户端），主动连接到另一个地方的“水管口”。它也可以扮演“水管口”的角色（服务器），在某个端口上“监听”，等待别人来连接。
### 1.用法 `直接连接到一个服务端口，发送一些数据，并查看服务器的响应   nc <主机地址> <端口号>`
#### - 示例： 连接到一个网站服务器的80端口，并手动发送一个HTTP请求 
#### ` nc www.example.com 80`
#### - 连接成功后，手动输入以下内容，然后按两次回车
#### ` GET / HTTP/1.1`
#### ` Host: www.example.com`
### 2.创建简单的聊天服务
#### 服务器端 (A电脑): 
#### - 在 1234 端口上监听
#### `nc -l -p 1234 [-l: (Listen) 监听模式。-p: (Port) 指定端口号。]`
#### 客户端 (B电脑):
#### 连接到 A 电脑的 1234 端口 (假设A的IP是192.168.1.10)
#### `nc 192.168.1.10 1234`
### 3.扫描端口
#### 相关参数：-v Verbose (详细)模式，会让nc打印出更详细的连接状态信息（例如“succeeded!”或“refused”），而不是成功后什么也不说。
#### -z: “零I/O模式”(Zero-I/O)。在这个模式下，nc在连接成功后会立即断开，而不会发送或接收任何数据，专门用于探测端口是否开放。
#### 示例1.扫描单个TCP端口 [确认某个服务的特定端口是否开放]
#### `nc -vz <主机地址> <端口号>[nc -vz scanme.nmap.org 80]`
#### 示例2.扫描一个连续的端口范围[检查一个服务器上的一段连续端口，可以直接用连字符 - 指定]
#### `nc -vz <主机地址> <起始端口>-<结束端口> [nc -vz scanme.nmap.org 20-25]`
#### 示例3.扫描udp端口[nc扫描的是TCP端口。如果要扫描UDP端口，需要加上 -u 参数]
#### `nc -vzu <主机地址> <端口号> [nc -vzu 8.8.8.8 53]`
#### 示例4.过滤输出，只看开放的端口 [当扫描大量端口时，满屏的“Connection refused”会很烦人,用grep命令来过滤结果。]
#### `nc -vz scanme.nmap.org 20-25 2>&1 | grep "succeeded"[nc -vz 在执行时，会产生两种输出：1.连接成功的信息 (例如 Connection to localhost 31790 port [tcp/*] succeeded!)，这部分内容被发送到“标准输出 (stdout)” 2.接失败的信息 (例如 nc: connect to localhost port 31001 (tcp) failed: Connection refused)，这部分内容被发送到“标准错误 (stderr)”。]`
#### 若只用 `nc -vz scanme.nmap.org 20-25 2>&1 | grep "succeeded` [管道符 | 默认只会将前一个命令的“标准输出 (stdout)”传递给后一个命令。它不会传递“标准错误 (stderr)”]

---
## openssl s_client
### 解释：通用的、功能极其强大的SSL/TLS加密客户端。可以把它看作是一个“加密版的 nc 或 telnet”
### 作用：在命令行终端里，手动地与任何使用SSL/TLS加密的服务端口（如HTTPS网站、加密邮件服务器等）进行连接和交互。
### 用法1.：` -showcerts 会打印出完整的证书链 openssl s_client -connect www.google.com:443 -showcerts`
### 用法2.：`The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL/TLS encryption. openssl s_client -connect localhost:30001 -quiet` 
---
## diff [(它的全称是 difference) 是一个“文本比较器”。它的核心工作，就是逐行比较两个文本文件，并找出它们之间的差异。]
### 用法 `diff <文件1> <文件2>`
## ssh命令的末尾加上ls（或其他任何命令）`ssh user@hostname "ls -la /home/user"`
### 作用： `登录到远程服务器，只执行这一个指定的命令，将结果显示在我的本地终端上，然后立刻自动断开连接，不进入交互式Shell。`
## * * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null 
### 1.*在此处为通配符，表示“每一个” 
### 2.bandit22： 这个脚本将以bandit22这个用户的身份和权限来运行
### 3./usr/bin/cronjob_bandit22.sh： 被执行的脚本文件的绝对路径
### 4.&> /dev/null(输出重定向)
#### - &>:等同于>/dev/null 2>&1
#### - &> /dev/null: 等同于 “无论这个脚本在执行时，是在屏幕上打印出正常信息（标准输出），还是打印出错误信息（标准错误输出），都不要显示出来，全部扔进黑洞”
## grep 
### 1.反选：-v 的含义是 --invert-match，即**“反转匹配”**
---
## more `核心作用是，当要查看一个很长的文本文件时，防止内容像瀑布一样快速滚过屏幕，而是让内容一页一页地显示`
## vim
### 1.:e `当正在编辑一个文件时，不退出Vim就去编辑另一个文件`
### 2.获得一个交互式shell `set shell=/bin/bash(若shell默认已更改)` :shell
## git
### 解释：“分布式版本控制系统”。它就像一个极其强大的“存档”和“协作”工具，专门为管理代码而生。可以把Git想象成一个拥有无限“撤销”和“存档”功能的游戏存档系统，并且这个系统还能让多个人一起打游戏（写代码）而互不干扰。
### 工作区 (Working Directory)：就是在电脑上能直接看到的、正在编辑的文件和文件夹。
### 暂存区 (Staging Area): 这是一个“待提交”的区域，像一个购物车。当对文件做了修改后，需要先把它“加入购物车”(git add)，告诉Git：“这个文件的这些改动，我准备要存档了。”
### 本地仓库 (Local Repository): 这是电脑上的“存档数据库”。当您把“购物车”里的所有东西都确认好后，您执行“结账”(git commit)操作，Git就会创建一个包含这些改动的、带有说明的永久性“存档点”。
### 流程：在工作区修改 -> 用 git add 放到暂存区 -> 用 git commit 存入本地仓库
### clone
### git log 命令的作用是“查看历史记录”。它会像一本“航海日志”一样，按照从近到远的时间顺序，列出当前分支上所有的“提交”(commit)记录。
### git show <commit> `若git log 是所有历史提交的“标题列表”，那么git show就是“深入查看”某一次具体提交的“详细内容”`
### git branch `用于管理项目中的“分支”。分支是Git实现多人协作、并行开发的核心功能。`
#### - 解释： 一个简单的比喻：将项目想象成一本正在创作中的小说，master / main 分支： 这是小说的“主线剧情”，是稳定、可发布的版本。
#### - 创建一个新分支 (branch)：写一个“番外篇”或尝试一种“新的剧情走向”。
#### - 在分支上工作: 在“番外篇”（新分支）上的所有修改，都完全不会影响到“主线剧情”（master分支）。可以自由地尝试、犯错、修改，直到对这个“番外篇”感到满意。
#### - 合并分支 (merge)：当觉得“番外篇”写得非常成功，可以并入主线时，就可以合并回master分支，让它成为主线剧情的一部分。
#### 相关用法 
#### - git branch `它会列出您本地仓库中所有的分支，并且会在您当前所在的分支名前面，用一个星号 * 标记出来`
#### - git checkout 
```
# 这是最常用的命令之一
git checkout -b new-feature
# 上面的命令等同于下面这两句：
# git branch new-feature  (创建分支)
# git checkout new-feature (切换到该分支)
#切回到主分支
git checkout main
```
#### git branch -a `若git branch 是查看“自己家（本地仓库）”有哪些分支，则 git branch -a 不仅能看到您自己家的所有分支，还能看到您“远方亲戚家（远程仓库，如GitHub）”有哪些分支。`
####
### git tag `git tag 命令的作用是“打标签”。它能在项目历史长河中的某一个特定的“提交”(commit)打上一个有意义的、永久性的标记，这个标记通常用来表示版本号。`
#### 解释： `git commit: 就像在写一本长篇小说时，每天保存一次进度。git log里会有成百上千个这样的日常保存记录，例如“写完了第三章草稿”、“修正了第二章的错别字”等。 git tag:当完成了“第一卷的最终版”时，不满足于一个普通的日常保存。拿出一张精美的书签，郑重地插在这一页，并写上“V1.0 - 正式发布版”**。这个“精美的书签”，就是git tag。`
#### 1.用法: git tag `它会按字母顺序列出您项目中所有的标签。`
#### 2.附注标签 (Annotated Tag) `git tag -a <标签名> -m "标签说明"` [-a: 代表 annotated (附注)] [-m: 代表 message (说明信息)]
#### 查看某个标签的详细信息 `git show v1.0`
### git commit `保存当前所做的更改` -a `确保所有修改/删除的文件都已暂存`
### git push `将本地的变更更新到远程仓库`
### git ignore `.gitignore文件, 包含所有提交过程中应忽略的文件名/扩展名. 通配符的支持: .py 表示忽略所有以.py结尾的文件`
### git add 更新哪些文件将成为下次提交的一部分。 -f标志强制提交文件
## `$0/$shell 运行shell`

`:shell脚本`
```#/bin/bash  
i=1
j="gb8KRRCsshuZXI0tUuR6ypOFjiZbf3G8"
while [ $i -le 1111 ]; do
        sum=$(printf  "%04d" $i)
        echo "${j} ${sum}"
        ((++i))
done
```
